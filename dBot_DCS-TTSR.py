############################
# CONFIGURATION PARAMETERS #
############################
ServerAddress = "192.168.0.146" # IPv4 address
ServerPort = 5555 # TCP port
FFMPEG_Path = "./ffmpeg/bin/ffmpeg.exe" # point to ffmpeg.exe
from dBotSecrets import SECRET_Token # from an external file, remember kids, never share your API keys
# -- CONFIGURATION PARAMETERS

import discord 
import socket
import asyncio
from gtts import gTTS
import datetime

AudioFilePath = "./temp/ttsAudio.mp3" # file that is generated by TTS and read by Discord
SocketAddress = (ServerAddress, ServerPort)
AddressFamily = socket.AF_INET # IPv4
SocketType = socket.SOCK_STREAM # TCP
SocketBacklog = 0 # maximum number of connections in the queue before they are droppped
BufferSize = 4096 # maximum size of data per message in bytes, DCS chat messages are presumably 100 characters maximum, assuming UTF-32, more than enough
SocketEncoding = "utf-8" 
TTS_Language = "en" # for the Discord-side command
TTS_Accent = "com" # also known as TLD, for the Discord-side command
CommandChar = "!" # command style : CommandChar + CommandName (lowercase, alphanumeric, no spaces)
CMD_Help = CommandChar + "help"
CMD_Start = CommandChar + "start"
CMD_Say = CommandChar + "say"
CMD_SayAs = CommandChar + "sayas"
CMD_Stop = CommandChar + "stop"
CMD_Commands = [CMD_Help, CMD_Start, CMD_Say, CMD_SayAs, CMD_Stop]
HelpText = (
        "Show this message", 
        "Start listening for DCS chat messages to read them in TTS in Discord ",
        "Read a Discord message in TTS in Discord",
        "Read a Discord message in TTS in Discord with a given language and accent (space separated)")

# Setup
intents = discord.Intents.default()
intents.message_content = True
_client = discord.Client(intents=intents)
b_Listen = False
VoiceChannel = None
# -- Setup

# Parse Discord message for a command and act upon it
async def ParseDiscordMessage(dMessage):
    message = dMessage.content
    if message.startswith(CommandChar):
        command = message.split(" ")[0]
        if command == CMD_Help:
            await Command_Help(dMessage)
        elif command == CMD_Start:
            await Command_Start(dMessage)
        elif command == CMD_Stop:
            await Command_Stop(dMessage)
        elif command == CMD_Say:
            await Command_Say(dMessage)
        elif command == CMD_SayAs:
            await Command_SayAs(dMessage)

# When bot logs on
@_client.event
async def on_ready():
    for guild in _client.guilds:
        print(_client.user.name + " has logged on to " + guild.name)

# When Discord message is sent
@_client.event
async def on_message(dMessage):
    if dMessage.author == _client.user: # ignore bot's own messages
        return
    await ParseDiscordMessage(dMessage)
    
# Reply to command user with a short help message
async def Command_Help(dMessage):
    WriteCommandToLog(dMessage.author.name, CMD_Help)
    message = "Available commands (command, context, description)"
    for i in range(0, len(CMD_Commands) - 1):
        message += "\n\n" + CMD_Commands[i] + ", " + HelpText[i]
    await dMessage.reply(message)

# Listen for messages from the socket client and read them
async def ListenForMessages(reader, writer):
    while True:
        message = await reader.read(BufferSize)
        message, accent = ParseTTS_Message(message)
        print(message)
        await ReadTTS(message, TTS_Language, accent, VoiceChannel)
        if not b_Listen:
            reader.close()
            await reader.wait_closed()
            writer.close()
            await reader.wait_closed()
            break

# TODO : display client information
# Listen for client connections
async def StartListeningToMessages():
    server = await asyncio.start_server(ListenForMessages, ServerAddress, ServerPort)
    print("Connection established, DISPLAY SERVER INFORMATION")
    async with server:
        await server.serve_forever()

# TODO : get rid of undesired characters
# TODO : make sure common acronyms and abbreviation are pronounced correctly
# Separate text and accent from a socket client message
def ParseTTS_Message(message):
    message = message.decode(SocketEncoding)
    message = message.split("_")
    accent = message[0]
    message = message[1]
    return message, accent

# TODO : force bot disconnect from voice channel?
# Stop listening for DCS chat messages
async def Command_Stop(dMessage):
    global b_Listen
    b_Listen = False
    WriteCommandToLog(dMessage.author.name, CMD_Stop)
    await dMessage.author.channel.send("Stopping to listen for DCS chat messages")

# Start listening for socket client DCS chat messages
async def Command_Start(dMessage):
    global b_Listen, VoiceChannel
    VoiceChannel = dMessage.author.voice.channel
    b_Listen = True
    WriteCommandToLog(dMessage.author.name, CMD_Start)
    await dMessage.author.channel.send("Starting to listen for DCS chat messages")

# Generate an audio file from a message and an accent and play it in a voice channel
async def ReadTTS(message, language, accent, voiceChannel):
    WriteToLog("Reading TTS message")
    audioFile = gTTS(text=message, lang=TTS_Language, tld=accent)
    audioFile.save(AudioFilePath)
    botChannel = voiceChannel.guild.voice_client
    if botChannel is None: # if the bot isn't in the channel already, connect
        botChannel = await voiceChannel.connect()
    audioData = discord.FFmpegPCMAudio(source=AudioFilePath, executable=FFMPEG_Path)
    botChannel.play(audioData)
    botChannel.source = discord.PCMVolumeTransformer(botChannel.source)
    botChannel.source.volume = 1
    while True:
        if botChannel.is_playing() and not botChannel.is_paused():
            await asyncio.sleep(1)
        else: break

# TODO : make use of this, also color ouput
# Wrapper for printing to the console
def WriteToLog(action):
    message = action + " at " + str(datetime.datetime.now())
    print(message)

# Wrapper for printing to the console
def WriteCommandToLog(user, commandName):
    message = user + " invoked " + commandName + " at " + str(datetime.datetime.now())
    print(message)

# Read a Discord message in TTS, mostly for debugging
async def Command_Say(dMessage):
    WriteCommandToLog(dMessage.author.name, CMD_Say)
    message = dMessage.content.split(CMD_Say + " ")[1]
    await ReadTTS(message, TTS_Language, TTS_Accent, dMessage.author.voice.channel)

# Read a Discord message in TTS as a given language and accent, for debugging
async def Command_SayAs(dMessage):
    WriteCommandToLog(dMessage.author.name, CMD_SayAs)
    message = dMessage.content.split(" ", 3)
    language = message[1]
    accent = message[2]
    message = message[3]
    await ReadTTS(message, language, accent, dMessage.author.voice.channel)



# The Discord bot can receive commands while the socket server is listening
async def Main():
    await asyncio.gather(_client.start(SECRET_Token), StartListeningToMessages())

# Program
asyncio.run(Main())
# -- Program
